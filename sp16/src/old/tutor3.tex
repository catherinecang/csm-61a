\documentclass{exam}
\usepackage{../../commonheader}

%%% CHANGE THESE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\discnumber{2}
\title{\textsc{Recursion, Tree recursion, and Orders of growth}}
\date{July 4 to July 10, 2015}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\maketitle
\rule{\textwidth}{0.15em}
\fontsize{12}{15}\selectfont

%%% INCLUDE TOPICS HERE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Higher Order Functions}

\begin{questions}

%%% Question %%%

\begin{blocksection}
\question Draw an environment diagram for the following code.

\begin{lstlisting}
tower = 12

def sather(gate):
    def tower():
        gate = 1
        return lambda tower: tower + gate
    return tower

campanile = sather(tower)
campanile()(12)
\end{lstlisting}
\end{blocksection}

\begin{solution}
   \includegraphics[scale=0.415]{sather.png} 
\end{solution}


%%% Question %%%

\begin{blocksection}
\question Implement \texttt{mystery}, a function that passes the following doctests:

%% Prompt %%
\begin{lstlisting}
def mystery(func, n):
    """
    >>> from operator import add, mul
    >>> a = mystery(add, 3)
    >>> a(4)
    7
    >>> a(12)
    15
    >>> b = mystery(lambda x, y: x*x + y, 4)
    >>> b(5)
    21
    >>> b(7)
    23
    """
\end{lstlisting}

\begin{solution}[1.5in]
\begin{lstlisting}
def mystery(func, n):
    def inner(y):
        return fn(n, y)
    return inner
\end{lstlisting}
\end{solution}
\end{blocksection}
\end{questions}

\section{Recursion}
\begin{questions}

%%% Question %%%

\begin{blocksection}

\question What is a recursive function?
\begin{solution}[0.5in]
A recursive function is a function that calls itself in its body, either
directly or indirectly.
\end{solution}

\question What are 3 important components that all recursive functions have?
\begin{solution}[1in]
\begin{enumerate}
    \item One or more base cases
    \item Way(s) to make the problem smaller
    \item One or more recursive cases
\end{enumerate}
\end{solution}


\question What is a tree recursive function? How is it different from a linearly
recursive function?
\begin{solution}[0.2in]
Tree recursive functions are functions that makes more than one recursive call.
This is different from linearly recursive functions (such as factorial), because
linearly recursive functions make exactly one recursive call in the recursive
case.
\end{solution}

\end{blocksection}

\begin{blocksection}

\question Do the following recursive functions work as intended? If not, find
the bug and fix it.

\begin{lstlisting}
def find_digit(number, digit):
    """Return true if the digit is included in the given
    number. Return false otherwise.

    >>> find_digit(4, 4)
    True
    >>> find_digit(4356, 4)
    True
    >>> find_digit(4356, 8)
    False
    >>> find_digit(3, 4)
    False
    """
    if number % 10 == digit:
        return True
    else:
        return find_digit(number // 10, digit)
\end{lstlisting}
\end{blocksection}

\begin{blocksection}
\begin{solution}[1.0in]
This function is missing another base case:

\begin{lstlisting}
    ...
    elif number < 10:
        return False
    ...
\end{lstlisting}
\end{solution}
\end{blocksection}

\begin{blocksection}
\begin{lstlisting}
def sum_digits(number):
    """Return the sum of all digits in a number.
    >>> sum_digits(4)
    4
    >>> sum_digits(43)
    7
    >>> sum_digits(123456789)
    45
    """
    if number < 10:
        return number
    else:
        return sum_digits(number % 10) + number // 10
\end{lstlisting}
\end{blocksection}

\begin{blocksection}
\begin{solution}[0.5in]
The recursive call is taking in the wrong argument. The recursive call to
\texttt{sum\_digits} is being given only the ones digit, but it should take
in the entire number \emph{without} the ones digit.

\begin{lstlisting}
    ...
        return sum_digits(number // 10) + number % 10
\end{lstlisting}
\end{solution}
\end{blocksection}

\begin{blocksection}
\question Implement \texttt{sorted\_digits(n)}, a function that takes in a
number \texttt{n} and returns True if the digits of \texttt{n} are increasing
from right to left.

\begin{lstlisting}
def sorted_digits(number):
    """Return True if the digit is in increasing order from
    rightmost digit to leftmost digit. (Consecutive digits
    that are the same are allowed.) Also return True if it
    has only one digit. Return False otherwise.

    >>> sorted_digits(2)
    True
    >>> sorted_digits(22222)
    True
    >>> sorted_digits(9876543210)
    True
    >>> sorted_digits(9087654321)
    False
    """
\end{lstlisting}

\begin{solution}[1.5in]
\begin{lstlisting}
    ones_digit = number % 10
    rest =  number // 10
    if rest == 0:
        return True
    elif ones_digit > rest % 10:
        return False
    else:
        return sorted_digits(rest)
\end{lstlisting}
\end{solution}
\end{blocksection}

\begin{blocksection}
\question Implement \texttt{path(n)}, which returns the number of paths from
one corner of an n x n grid to the opposite corner.

Consider an insect in an N by N grid. The insect starts at the bottom left
corner, (0, 0), and wants to end up at the top right corner, (N-1, N-1). The
insect is only capable of moving right or up. Write a function paths that takes
a grid length and width and returns the number of different paths the insect can
take from the start to the goal. (There is a closed-form solution to this
problem, but try to answer it procedurally using recursion.)

\centerline{\includegraphics[scale = 0.75]{paths.png}}

For example, the 2 by 2 grid has a total of two ways for the insect to move from
the start to the goal. For the 3 by 3 grid, the insect has 6 different paths
(only 3 are shown above).

\begin{lstlisting}

def paths(n):
    """Return the number of paths from one corner of an
    N by N grid to the opposite corner.

    >>> paths(2)
    2
    >>> paths(3)
    6
    >>> paths(10)
    48620
    """
\end{lstlisting}

\begin{solution}[1.5in]
\begin{lstlisting}
    def helper(row, col):
        if row == 1 or col == 1:
            return 1
        return helper(row-1, col) + helper(row, col-1)
    return helper(n, n)
\end{lstlisting}
\end{solution}

\end{blocksection}
\end{questions}

\section{Orders of growth}

\begin{questions}

%%% Question %%%

\begin{blocksection}
\question Write down the orders of growth for the following functions in terms of n. 

\begin{lstlisting}
def a(n):
    if n <= 0:
        return 1
    return 1 + a(n // 2)
\end{lstlisting}

\begin{solution}[0.5in]
$O(\log(n))$
\end{solution}

\begin{lstlisting}
def loopy(n):
    result = 0
    while n > 0:
        result += n
        n -= 1
    return result
\end{lstlisting}

\begin{solution}[0.5in]
$O(n)$
\end{solution}

\end{blocksection}
\end{questions}

\end{document}
