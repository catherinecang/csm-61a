\documentclass{exam}
\usepackage{../../commonheader}

%%% CHANGE THESE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\discnumber{3}
\title{\textsc{Linked Lists}}
\date{February 22 to February 26, 2016}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\maketitle
\rule{\textwidth}{0.15em}
\fontsize{12}{15}\selectfont

%%% INCLUDE TOPICS HERE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%% Question %%%

\begin{questions}
\begin{blocksection}
\question Given the following code, what will Python output for the following prompts? 

\begin{lstlisting}
class Baller:
	all_players = []
	def __init__(self, name, has_ball = False):
		self.name = name
		self.has_ball = has_ball
		Baller.all_players.append(self)
	
	def pass_ball(self, other_player):
		if self.has_ball:
		self.has_ball = False
		other_player.has_ball = True
		return True
	else:
		return False

class BallHog(Baller):
	def pass_ball(self, other_player):	
		return False	
\end{lstlisting}

\begin{lstlisting}
>>> tiffany = Baller('Tiffany', True)
>>> garrett = BallHog('Garrett')
>>> len(Baller.all_players)
\end{lstlisting}
\begin{solution}[.2in]
2
\end{solution}

\begin{lstlisting}
>>> Baller.name
\end{lstlisting}
\begin{solution}[.2in]
Error
\end{solution}

\begin{lstlisting}
>>> len(garrett.all_players)
\end{lstlisting}
\begin{solution}[.2in]
2
\end{solution}
\end{blocksection}

\begin{blocksection}
\begin{lstlisting}
>>> tiffany.pass_ball()
\end{lstlisting}
\begin{solution}[.2in]
Error
\end{solution}

\begin{lstlisting}
>>> tiffany.pass_ball(garrett)
\end{lstlisting}
\begin{solution}[.2in]
True
\end{solution}

\begin{lstlisting}
>>> tiffany.pass_ball(garrett)
\end{lstlisting}
\begin{solution}[.2in]
False
\end{solution}

\begin{lstlisting}
>>> BallHog.pass_ball(garrett, tiffany)
\end{lstlisting}
\begin{solution}[.2in]
False
\end{solution}

\begin{lstlisting}
>>> garrett.pass_ball(tiffany)
\end{lstlisting}
\begin{solution}[.2in]
False
\end{solution}

\begin{lstlisting}
>>> garrett.pass_ball(garrett, tiffany)
\end{lstlisting}
\begin{solution}[.2in]
Error
\end{solution}
\end{blocksection}

%%% Question %%%
\begin{blocksection}
\question Write a function \texttt{skip}, which takes in a \texttt{Link} and returns a new \texttt{Link}.

\begin{lstlisting}
def skip(lst):
    """
    >>> a = Link(1, Link(2, Link(3, Link(4))))
    >>> a
    Link(1, Link(2, Link(3, Link(4))))
    >>> b = skip(a)
    >>> b
    Link(1, Link(3))
    >>> a
    Link(1, Link(2, Link(3, Link(4)))) # Original is unchanged
    """
\end{lstlisting}
\begin{solution}[1in]
\begin{lstlisting}
    if lst is Link.empty:
        return Link.empty
    if lst.rest is Link.empty:
        return lst
    return Link(lst.first, skip(lst.rest.rest))
\end{lstlisting}
\end{solution}
\end{blocksection}

%%% Question %%%

\begin{blocksection}
\question Now write function \texttt{skip} by mutating the original list, instead of returning a new list. Do NOT call the \texttt{Link} constructor.

\begin{lstlisting}
def skip(lst):
    """
    >>> a = Link(1, Link(2, Link(3, Link(4))))
    >>> b = skip(a)
    >>> b
    Link(1, Link(3))
    >>> a
    Link(1, Link(3))
    """
\end{lstlisting}

\begin{solution}[1in]
\begin{lstlisting}
def skip(lst): # Recursively
    if lst is Link.empty or lst.rest is Link.empty:
        return lst
    lst.rest = skip(lst.rest.rest)
        return lst

def skip(lst): # Iteratively
    if lst is Link.empty:
        return Link.empty
    original = lst
    while lst.rest is not Link.empty:
        lst.rest = lst.rest.rest
        lst = lst.rest
    return original
\end{lstlisting}
\end{solution}

\end{blocksection}

\begin{blocksection}
\question Write a function \texttt{reverse}, which takes in a \texttt{Link} and
returns a new \texttt{Link} that has the order of the contents reversed.\\
\emph{Hint:} You may want to use a helper function if you're solving this
recursively.
\begin{lstlisting}
def reverse(lst):
    """
    >>> a = Link(1, Link(2, Link(3)))
    >>> b = reverse(a)
    >>> b
    Link(3, Link(2, Link(1)))
    >>> a
    Link(1, Link(2, Link(3)))
    """
\end{lstlisting}

\begin{solution}[1in]
There are quite a few different methods. We have listed some here -- can you
think of any others?
\begin{lstlisting}
# Recursive w/ Helper
def reverse(lst):
    def helper(so_far, rest):
        if rest is Link.empty:
            return so_far
        else:
            return helper(Link(rest.first, so_far), rest.rest)
    return helper(Link.empty, lst)

# Recursive w/o Helper
def reverse(lst):
    if lst is Link.empty or lst.rest is Link.empty:
        return lst
    secondElement = lst.rest
    lst.rest = Link.empty
    reversedRest = reverse(secondElement)
    secondElement.rest = lst
    return reversedRest

# Iterative
def reverse(lst):
    rev = Link.empty
    while lst is not Link.empty:
        rev = Link(lst.first, rev)
        lst = lst.rest
    return rev
\end{lstlisting}
\end{solution}

\end{blocksection}

\begin{blocksection}
\question \textbf{(Optional)} Implement negation so that linked lists have the
following behaviour:

\begin{lstlisting}
>>> a = Link(1, Link(2, Link(3)))
>>> -a # This should output a new Linked List
Link(3, Link(2, Link(1)))
\end{lstlisting}

You may use your work from question 4.\\
\textit{Hint:}
\begin{lstlisting}
>>> a = 4
>>> -a
-4
>>> a.__neg__()
-4
\end{lstlisting}

\begin{solution}[0.3in]
\begin{lstlisting}
# In class Link
def __neg__(self):
    return reverse(self)
\end{lstlisting}
\end{solution}

\end{blocksection}

\begin{blocksection}
\question \textbf{(Optional)} Now write \texttt{reverse} by modifying the existing Links. Assume reverse returns the head of the new list (so the last \texttt{Link} object of the previous list).

First, draw out the box and pointer for the following:
\begin{lstlisting}
>>> a = Link(1, Link(2))
>>> a.rest.rest = a
>>> a.rest = Link.empty
\end{lstlisting}
Observe how the pointers change, as well as the order in which they are
modified.
\begin{solution}[0.6in]
\begin{lstlisting}
   +---+---+  +---+---+
+->| 1 | / |  | 2 | --|--+
|  +---+---+  +---+---+  |
|                        |
+------------------------+
\end{lstlisting}
\end{solution}
\end{blocksection}

\begin{blocksection}
Now, generalize this to reverse an entire linked list.
\begin{lstlisting}
def reverse(lst):
    """
    >>> a = Link(1, Link(2, Link(3)))
    >>> b = reverse(a)
    >>> b
    Link(3, Link(2, Link(1)))
    >>> a
    Link(3, Link(2, Link(1)))
    """
\end{lstlisting}
\begin{solution}[1.25in]
Here are two possible solutions.
\begin{lstlisting}
def reverse(lst):
    if lst == Link.empty or lst.rest == Link.empty:
        return lst
    else:
        new_start = reverse(lst.rest)
        lst.rest.rest = lst
        lst.rest = Link.empty
        return new_start

def reverse(lst):
    if lst.rest is not Link.empty:
        second, last = lst.rest, lst
        lst = reverse(second)
        second.rest, last.rest = last, Link.empty
    return lst
\end{lstlisting}
\end{solution}


\end{blocksection}

\begin{blocksection}
\question \textbf{(Optional)} Write \texttt{has\char`_cycle} which takes in a
\texttt{Link} \texttt{True} if and only if there is a cycle in the
\texttt{Link}.

\begin{lstlisting}
def has_cycle(s):
    """
    >>> has_cycle(Link.empty)
    False
    >>> a = Link(1, Link(2, Link(3)))
    >>> has_cycle(a)
    False
    >>> a.rest.rest.rest = a
    >>> has_cycle(a)
    True
    """
\end{lstlisting}

\begin{solution}
\begin{lstlisting}
     if s is Link.empty:
            return False
        slow, fast = s, s.rest
        while fast is not Link.empty:
            if fast.rest is Link.empty:
                return False
            elif fast is slow or fast.rest is slow:
                return True
            slow, fast = slow.rest, fast.rest.rest
        return False
\end{lstlisting}
\end{solution}

\end{blocksection}

\end{questions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
