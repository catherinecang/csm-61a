\documentclass{exam}
\usepackage{../../commonheader}

%%% CHANGE THESE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\discnumber{4}
\title{\textsc{Linked Lists}}
\date{October 10 to October 14, 2016}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\maketitle
\rule{\textwidth}{0.15em}
\fontsize{12}{15}\selectfont

%%% INCLUDE TOPICS HERE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%% Question %%%

\begin{blocksection}
For each of the following problems, assume linked lists are defined as follows:
\newline
\begin{lstlisting}
class Link:

    empty = ()

    def __init__(self, first, rest=empty):
        assert rest is Link.empty or isinstance(rest, Link)
        self.first = first
        self.rest = rest
\end{lstlisting}

To check if a \texttt{Link} is empty, compare it against the class attribute \texttt{Link.empty}:
\newline
\begin{lstlisting}
if link is Link.empty:
    print('This linked list is empty!')
\end{lstlisting}
\end{blocksection}

\section{What Would Python Print?}
\begin{questions}
\begin{blocksection}
\question What will Python output? Draw box-and-pointer diagrams to help determine this.

\begin{lstlisting}
>>> a = Link(1, Link(2, Link(3)))
\end{lstlisting}
\begin{solution}[0in]
\begin{lstlisting}
+---+---+  +---+---+  +---+---+
| 1 | --|->| 2 | --|->| 3 | / |
+---+---+  +---+---+  +---+---+
\end{lstlisting}
\end{solution}

\begin{lstlisting}
>>> a.first
\end{lstlisting}
\begin{solution}[.25in]
\begin{lstlisting}
1
\end{lstlisting}
\end{solution}

\begin{lstlisting}
>>> a.first = 5
\end{lstlisting}
\begin{solution}[0in]
\begin{lstlisting}
+---+---+  +---+---+  +---+---+
| 5 | --|->| 2 | --|->| 3 | / |
+---+---+  +---+---+  +---+---+
\end{lstlisting}
\end{solution}

\begin{lstlisting}
>>> a.first
\end{lstlisting}
\begin{solution}[.25in]
5
\end{solution}

\begin{lstlisting}
>>> a.rest.first
\end{lstlisting}
\begin{solution}[.25in]
2
\end{solution}

\begin{lstlisting}
>>> a.rest.rest.rest.rest.first
\end{lstlisting}
\begin{solution}[.25in]
Error: ‘tuple’ object has no attribute ‘rest’ (Link.empty has no rest)
\end{solution}
\end{blocksection}

\begin{blocksection}
\begin{lstlisting}
>>> a.rest.rest.rest = a
\end{lstlisting}
\begin{solution}[0in]
\begin{lstlisting}
   +---+---+  +---+---+  +---+---+
+->| 5 | --|->| 2 | --|->| 3 | --|--+
|  +---+---+  +---+---+  +---+---+  |
|                                   |
+-----------------------------------+
\end{lstlisting}
\end{solution}

\begin{lstlisting}
>>> a.rest.rest.rest.rest.first
\end{lstlisting}
\begin{solution}[.25in]
\begin{lstlisting}
2
\end{lstlisting}
\end{solution}

\end{blocksection}

\section{Code Writing Questions}

%%% Question %%%
\begin{blocksection}
\question Write a function \texttt{skip}, which takes in a \texttt{Link} and returns a new \texttt{Link}.

\begin{lstlisting}
def skip(lst):
    """
    >>> a = Link(1, Link(2, Link(3, Link(4))))
    >>> a
    Link(1, Link(2, Link(3, Link(4))))
    >>> b = skip(a)
    >>> b
    Link(1, Link(3))
    >>> a
    Link(1, Link(2, Link(3, Link(4)))) # Original is unchanged
    """
\end{lstlisting}
\begin{solution}[1in]
\begin{lstlisting}
    if lst is Link.empty or lst.rest is Link.empty:
        return lst
    return Link(lst.first, skip(lst.rest.rest))
\end{lstlisting}
\end{solution}
\end{blocksection}

%%% Question %%%

\begin{blocksection}
\question Now write function \texttt{skip} by mutating the original list, instead of returning a new list. Do NOT call the \texttt{Link} constructor.

\begin{lstlisting}
def skip(lst):
    """
    >>> a = Link(1, Link(2, Link(3, Link(4))))
    >>> b = skip(a)
    >>> b
    Link(1, Link(3))
    >>> a
    Link(1, Link(3))
    """
\end{lstlisting}

\begin{solution}[1in]
\begin{lstlisting}
def skip(lst): # Recursively
    if lst is Link.empty or lst.rest is Link.empty:
        return lst
    lst.rest = skip(lst.rest.rest)
    return lst

def skip(lst): # Iteratively
    if lst is Link.empty:
        return Link.empty
    original = lst
    while lst.rest is not Link.empty:
        lst.rest = lst.rest.rest
        lst = lst.rest
    return original
\end{lstlisting}
\end{solution}

\end{blocksection}

\begin{blocksection}
\question Write a function \texttt{reverse}, which takes in a \texttt{Link} and
returns a new \texttt{Link} that has the order of the contents reversed.\\
\emph{Hint:} You may want to use a helper function if you're solving this
recursively.
\begin{lstlisting}
def reverse(lst):
    """
    >>> a = Link(1, Link(2, Link(3)))
    >>> b = reverse(a)
    >>> b
    Link(3, Link(2, Link(1)))
    >>> a
    Link(1, Link(2, Link(3)))
    """
\end{lstlisting}

\begin{solution}[1in]
There are quite a few different methods. We have listed some here -- can you
think of any others?
\begin{lstlisting}
# Recursive w/ Helper
def reverse(lst):
    def helper(so_far, rest):
        if rest is Link.empty:
            return so_far
        else:
            return helper(Link(rest.first, so_far), rest.rest)
    return helper(Link.empty, lst)

# Iterative
def reverse(lst):
    rev = Link.empty
    while lst is not Link.empty:
        rev = Link(lst.first, rev)
        lst = lst.rest
    return rev
\end{lstlisting}
\end{solution}

\end{blocksection}

\begin{blocksection}
\question \textbf{(Optional)} Now write \texttt{reverse} by modifying the existing Links. Assume reverse returns the head of the new list (so the last \texttt{Link} object of the previous list).

First, draw out the box and pointer for the following:
\begin{lstlisting}
>>> a = Link(1, Link(2))
>>> a.rest.rest = a
>>> a.rest = Link.empty
\end{lstlisting}
Observe how the pointers change, as well as the order in which they are
modified.
\begin{solution}[0.6in]
\begin{lstlisting}
   +---+---+  +---+---+
+->| 1 | / |  | 2 | --|--+
|  +---+---+  +---+---+  |
|                        |
+------------------------+
\end{lstlisting}
\end{solution}
\end{blocksection}

\begin{blocksection}
Now, generalize this to reverse an entire linked list.
\begin{lstlisting}
def reverse(lst):
    """
    >>> a = Link(1, Link(2, Link(3)))
    >>> b = reverse(a)
    >>> b
    Link(3, Link(2, Link(1)))
    >>> a
    Link(1)
    """
\end{lstlisting}
\begin{solution}[1.00in]
Here are two possible solutions.
\begin{lstlisting}
def reverse(lst):
    if lst == Link.empty or lst.rest == Link.empty:
        return lst
    else:
        new_start = reverse(lst.rest)
        lst.rest.rest = lst
        lst.rest = Link.empty
        return new_start

def reverse(lst):
    if lst.rest is not Link.empty:
        second, last = lst.rest, lst
        lst = reverse(second)
        second.rest, last.rest = last, Link.empty
    return lst
\end{lstlisting}
\end{solution}


\end{blocksection}

\begin{blocksection}
\question \textbf{(Optional)} Write \texttt{has\char`_cycle} which takes in a
\texttt{Link} and returns \texttt{True} if and only if there is a cycle in the
\texttt{Link}.

\begin{lstlisting}
def has_cycle(s):
    """
    >>> has_cycle(Link.empty)
    False
    >>> a = Link(1, Link(2, Link(3)))
    >>> has_cycle(a)
    False
    >>> a.rest.rest.rest = a
    >>> has_cycle(a)
    True
    """
\end{lstlisting}

\begin{solution}[1.00in]
\begin{lstlisting}
    if s is Link.empty:
        return False
    slow, fast = s, s.rest
    while fast is not Link.empty:
        if fast.rest is Link.empty:
            return False
        elif fast is slow or fast.rest is slow:
            return True
        slow, fast = slow.rest, fast.rest.rest
    return False
\end{lstlisting}
\end{solution}

\end{blocksection}

\begin{blocksection}
\question \textbf{Orders of Growth and Linked Lists:} Consider the following
linked list function:
\begin{lstlisting}
def insert_at_beginning(lst, x):
    return Link(x, lst)
\end{lstlisting}

\begin{parts}
\part What does this function do?

\begin{solution}
It takes in an existing lst and returns a new list with $x$ at the front.
\end{solution}

\part Assume lst is initially length $n$. How long does it take to do one
insert? Two? $n$?
\begin{solution}
All inserts will take constant time. No matter how long the list is, it doesn't
take any longer to add to the front. One insert will take one unit of time, and
two will take roughly twice that. Therefore, the amount of time to do $n$
inserts will be $O(n)$.
\end{solution}

Now consider:
\begin{lstlisting}
def insert_at_end(lst, x):
    if lst.rest is Link.empty:
        lst.rest = Link(x)
    else:
        insert_at_end(lst.rest, x)
\end{lstlisting}

\part What does this function do?
\begin{solution}[0.25in]
    Inserts a value \texttt{x} at the end of linked list \texttt{lst}.
\end{solution}
\part Say we want to repeatedly insert some numbers into the end of a linked
list:
\begin{lstlisting}
def insert_many_end(lst, n):
    for i in range(n):
        insert_at_end(lst, i)
\end{lstlisting}
\begin{subparts}

\subpart Assume \texttt{lst} is initially length 1. How long will it take to do
the first insertion? The second? The $n$th?
\begin{solution}[0.25in]
Notice that the list gets longer with each insertion, so each operation will
make it harder to do the next.
Therefore, the first insertion will take about 1 unit of time. The second will
take about twice as long, at two units of time. The $n$th insertion will take
$n$ units of time.
\end{solution}

\subpart In big-O notation, What is the total runtime to do all the inserts?
(total runtime of \texttt{insert\char`_many\char`_end})
\begin{solution}[0.25in]
The total runtime will be the sum of all the inserts: 1 + 2 + 3 + \ldots + $n$ =
$\frac{n (n + 1)}{2}$ = $O(n^{2})$
\end{solution}

\end{subparts}

\end{parts}
\end{blocksection}

\end{questions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
