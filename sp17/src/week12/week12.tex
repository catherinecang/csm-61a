\documentclass{exam}
\usepackage{../../commonheader}
\lstset{language=Scheme}

%%% CHANGE THESE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\discnumber{9}
\title{\textsc{Tail Recursion and Streams}}
\date{April 10 to April 14, 2017}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\maketitle
\rule{\textwidth}{0.15em}
\fontsize{12}{15}\selectfont

%%% INCLUDE TOPICS HERE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Tail Recursion}
\begin{questions}
\question What is a tail context/tail call? What is a tail recursive function?
\begin{solution}[0.5in]
A tail call is a call expression in a tail context. A tail context is usually the final action of a procedure/function.\newline
\newline
A tail recursive function is where all the recursive calls of the function are in tail contexts. \newline
\newline
An ordinary recursive function is like building up a long chain of domino pieces, then knocking down the last one. A tail recursive function is like putting a domino piece up, knocking it down, putting a domino piece up again, knocking it down again, and so on. This metaphor helps explain why tail calls can be done in constant space, whereas ordinary recursive calls need space linear to the number of frames (in the metaphor, domino pieces are equivalent to frames).
\end{solution}
\question Why are tail calls useful for recursive functions?
\begin{solution}[0.5in]
When a function is tail recursive, it can effectively discard all the past recursive frames and only keep the current frame in memory. This means we can use a constant amount of memory with recursion, and that we can deal with an unbounded number of tail calls with our Scheme interpreter.
\end{solution}

Answer the following questions with respect to the following function:
\begin{lstlisting}
(define (sum-list lst)
  (if (null? lst)
    0
    (+ (car lst) (sum-list (cdr lst)))
  )
)
\end{lstlisting}
\question Why is sum-list not a tail call? Optional: draw out the environment diagram of this sum-list with list: (1 2 3). When do you add 2 and 3?
\begin{solution}[0.5in]
Sum list is not the last call we make, it’s actually the other addition which we do after we evaluate sum-list. Sum list is not the last expression we evaluate.
\end{solution}
\question Rewrite sum-list in a tail recursive context.
\begin{solution}[0.5in]
\begin{lstlisting}
(define (sum-list-tail lst)
  (define (sum-list-helper lst sofar)
    (if (null? lst)
      sofar
      (sum-list-helper (cdr lst) (+ sofar (car lst)))
    )
  )
  (sum-list-helper lst 0)
)
\end{lstlisting}
\end{solution}

\end{questions}

\section{Streams}
A \texttt{Stream} is a linked list where the first element is calculated, but the
 \texttt{rest} isn’t until it is needed. Here is the definiton of \texttt{Stream}:

\begin{lstlisting}
class Stream:
    class empty:
        def __repr__(self):
            return 'Stream.empty'

    empty = empty()

    def __init__(self, first, compute_rest=lambda: Stream.empty):
       assert callable(compute_rest), 'compute_rest must  be callable.'
       self.first = first
       self._compute_rest = compute_rest

    @property
    def rest(self):
      """Return the rest of the stream, computing it if necessary."""
        if self._compute_rest is not None:
            self._rest = self._compute_rest()
            self._compute_rest = None
        return self._rest

    def __repr__(self):
        return 'Stream({0}, <...>)'.format(repr(self.first))

empty_stream = Stream.empty
\end{lstlisting}

Here is an example of how to construct a \texttt{Stream} of integers:
\begin{lstlisting}

def make_integer_stream(first=1):
    def compute_rest():
        print(“computing rest”)
        return make_integer_stream(first+1)
    return Stream(first, compute_rest)
\end{lstlisting}

\clearpage

\subsection{General Streams}
\begin{questions}
\question What’s the advantage of using a stream over a linked list?
\begin{solution}[0.5in] 
Lazy evaluation. We only evaluate up to what we need.
\end{solution}

\question What’s the maximum size of a stream?
\begin{solution}[0.5in]
Infinity
\end{solution}

\question What’s stored in first and rest? What are their types? 
\begin{solution}[0.5in]
First is a value, rest is another stream (either a method to calculate it, or an already calculated stream).
\end{solution}

\question When is the next element actually calculated?
\begin{solution}[.5in]
Only when it's requested (and hasn't already been calculated)
\end{solution}
\end{questions}


\subsection{What Would Python Print?}
\begin{questions}
\item  For each of the following lines of code, write what Python would output.

\begin{lstlisting}
>>> a = make_integer_stream()
>>> a
\end{lstlisting}
\begin{solution}[.45in]
\texttt{Stream(1, <...>)}
\end{solution}

\begin{lstlisting}
>>> a.first
\end{lstlisting}
\begin{solution}[.45in]
\texttt{1}
\end{solution}

\begin{lstlisting}
>>> a.rest
\end{lstlisting}
\begin{solution}[.45in]
\begin{lstlisting}
computing rest
Stream(2, <...>)
\end{lstlisting}
\end{solution}

\begin{lstlisting}
>>> a.rest
\end{lstlisting}
\begin{solution}[.45in]
\texttt{Stream(2, <...>)}
\end{solution}

\begin{lstlisting}
>>> a.rest.rest.rest
\end{lstlisting}
\begin{solution}[.45in]
\begin{lstlisting}
computing rest
computing rest
Stream(4, <...>)
\end{lstlisting}
\end{solution}


\begin{lstlisting}
>>> a.rest.rest
\end{lstlisting}
\begin{solution}[.45in]
\texttt{Stream(3, <...>)}
\end{solution}

\begin{lstlisting}
>>> a.rest.rest.rest.rest.first
\end{lstlisting}
\begin{solution}
\begin{lstlisting}
computing rest
5
\end{lstlisting}
\end{solution}
\end{questions}

\subsection{Code Writing for Streams}

%%% Question %%%
\begin{questions}
\question Write out \texttt{double\_naturals}, which is a stream that evaluates to the sequence 1, 1, 2, 2, 3, 3, etc.
\begin{lstlisting}
def double_natural(first=1, flag=0):
  """
    >>> a = double_natural()
  >>> a.first
  1
  >>> a.rest.rest.first
  computing rest
  computing rest
  2
  """
  def compute_rest():
    print('computing rest')
    #Your code here












  return Stream(first, compute_rest)
\end{lstlisting}

\begin{solution}
\begin{lstlisting}
    if go_next:
      return double_natural(first+1, go_next=False)
    return double_natural(first, go_next=True)
\end{lstlisting}
\end{solution}

\clearpage

\question Write out \texttt{interleave}, which returns a stream that alternates between the values in \texttt{stream1} and \texttt{stream2}. Assume that the streams are infinitely long.
\begin{lstlisting}
def interleave(stream1, stream2):
  """
  Note: ignore "compute rest" prints from make_integer_stream.
  >>> s1, s2 = make_integer_stream(1), make_integer_stream(10)
  >>> mixed = interleave(s1, s2)
  >>> mixed.first
  1
  >>> mixed.rest.first
  10
  >>> very_mixed = interleave(mixed, mixed)
  >>> very_mixed.first
  1
  >>> very_mixed.rest.first
  1
  >>> very_mixed.rest.rest.first
  10
  >>> very_mixed.rest.rest.rest.first
  10
  """

\end{lstlisting}

\begin{solution}
\begin{lstlisting}
def compute_rest():
    return interleave(stream2, stream1.rest)
  return Stream(stream1.first, compute_rest)
\end{lstlisting}
\end{solution}
\end{questions}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}

